{"version":3,"file":"tokens.js","sourceRoot":"./@jupyterlab/git/src/","sources":["tokens.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,KAAK,EAAc,MAAM,mBAAmB,CAAC;AAKtD,MAAM,CAAC,MAAM,YAAY,GAAG,+BAA+B,CAAC;AAE5D,MAAM,CAAC,MAAM,aAAa,GAAG,IAAI,KAAK,CAAgB,YAAY,CAAC,CAAC","sourcesContent":["import { IChangedArgs } from '@jupyterlab/coreutils';\nimport { DocumentRegistry } from '@jupyterlab/docregistry';\nimport { Token, JSONObject } from '@lumino/coreutils';\nimport { IDisposable } from '@lumino/disposable';\nimport { ISignal } from '@lumino/signaling';\nimport { CommandRegistry } from '@lumino/commands';\n\nexport const EXTENSION_ID = 'jupyter.extensions.git_plugin';\n\nexport const IGitExtension = new Token<IGitExtension>(EXTENSION_ID);\n\n/** Interface for extension class */\nexport interface IGitExtension extends IDisposable {\n  /**\n   * The list of branch in the current repo\n   */\n  branches: Git.IBranch[];\n\n  /**\n   * The current branch\n   */\n  currentBranch: Git.IBranch;\n\n  /**\n   * A signal emitted when the `HEAD` of the Git repository changes.\n   */\n  readonly headChanged: ISignal<IGitExtension, void>;\n\n  /**\n   * A signal emitted whenever a model event occurs.\n   */\n  readonly logger: ISignal<IGitExtension, string>;\n\n  /**\n   * Top level path of the current Git repository\n   */\n  pathRepository: string | null;\n\n  /**\n   * A signal emitted when the current Git repository changes.\n   */\n  readonly repositoryChanged: ISignal<IGitExtension, IChangedArgs<string>>;\n\n  /**\n   * Test whether the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  isReady: boolean;\n\n  /**\n   * A promise that fulfills when the model is ready;\n   * i.e. if the top folder repository has been found.\n   */\n  ready: Promise<void>;\n\n  /**\n   * Files list resulting of a Git status call.\n   */\n  readonly status: Git.IStatusFileResult[];\n\n  /**\n   * A signal emitted when the current status of the Git repository changes.\n   */\n  readonly statusChanged: ISignal<IGitExtension, Git.IStatusFileResult[]>;\n\n  readonly commands: CommandRegistry | null;\n\n  /**\n   * Make request to add one or all files into\n   * the staging area in repository\n   *\n   * If filename is not provided, all files will be added.\n   *\n   * @param filename Optional name of the files to add\n   */\n  add(...filename: string[]): Promise<Response>;\n\n  /**\n   * Make request to add all unstaged files into\n   * the staging area in repository 'path'\n   */\n  addAllUnstaged(): Promise<Response>;\n\n  /**\n   * Make request to add all untracked files into\n   * the staging area in repository\n   */\n  addAllUntracked(): Promise<Response>;\n\n  /**\n   * Add the file named fname to the current marker with given mark\n   *\n   * @param fname Filename\n   * @param mark Mark to set\n   */\n  addMark(fname: string, mark: boolean): void;\n\n  /**\n   * Get current mark of file named fname\n   *\n   * @param fname Filename\n   * @returns Mark of the file\n   */\n  getMark(fname: string): boolean;\n\n  /**\n   * Toggle the mark for the file named fname\n   *\n   * @param fname Filename\n   */\n  toggleMark(fname: string): void;\n\n  /**\n   * Add a remote Git repository to the current repository\n   *\n   * @param url Remote repository URL\n   * @param name Remote name\n   */\n  addRemote(url: string, name?: string): Promise<void>;\n\n  /**\n   * Make request for all Git info of the repository\n   * (This API is also implicitly used to check if the current repo is a Git repo)\n   *\n   * @param historyCount: Optional number of commits to get from Git log\n   * @returns Repository history\n   */\n  allHistory(historyCount?: number): Promise<Git.IAllHistory>;\n\n  /** Make request to switch current working branch,\n   * create new branch if needed,\n   * or discard a specific file change or all changes\n   * TODO: Refactor into seperate endpoints for each kind of checkout request\n   *\n   * If a branch name is provided, check it out (with or without creating it)\n   * If a filename is provided, check the file out\n   * If nothing is provided, check all files out\n   *\n   * @param options Checkout options\n   * @returns Command execution status\n   */\n  checkout(options?: Git.ICheckoutOptions): Promise<Git.ICheckoutResult>;\n\n  /**\n   * Make request for the Git clone API.\n   *\n   * @param path Local path in which the repository will be cloned\n   * @param url Distant Git repository URL\n   * @param auth Optional authentication information for the remote repository\n   * @returns Command execution status\n   */\n  clone(path: string, url: string, auth?: Git.IAuth): Promise<Git.ICloneResult>;\n\n  /**\n   * Make request to commit all staged files in repository\n   *\n   * @param message Commit message\n   */\n  commit(message: string): Promise<Response>;\n\n  /**\n   * Get or set Git configuration options\n   *\n   * @param options Configuration options to set (undefined to get)\n   */\n  config(options?: JSONObject): Promise<Response>;\n\n  /**\n   * Make request to revert changes from selected commit\n   *\n   * @param message Commit message to use for the new repository state\n   * @param commitId Selected commit ID\n   */\n  revertCommit(message: string, commitId: string): Promise<Response>;\n\n  /**\n   * Make request for detailed Git commit info of\n   * commit 'hash'\n   *\n   * @param hash Commit hash\n   * @returns Detailed log of the commit\n   */\n  detailedLog(hash: string): Promise<Git.ISingleCommitFilePathInfo>;\n\n  /**\n   * Gets the path of the file relative to the Jupyter server root.\n   *\n   * If no path is provided, returns the Git repository top folder relative path.\n   * If no Git repository selected, return null\n   *\n   * @param path the file path relative to Git repository top folder\n   * @returns Relative file path to the server root\n   */\n  getRelativeFilePath(path?: string): string | null;\n\n  /**\n   * Make request to initialize a  new Git repository at path 'path'\n   *\n   * @param path Folder path to initialize as a Git repository.\n   */\n  init(path: string): Promise<Response>;\n\n  /**\n   * Make request for Git commit logs\n   *\n   * @param historyCount: Optional number of commits to get from Git log\n   * @returns Repository logs\n   */\n  log(historyCount?: number): Promise<Git.ILogResult>;\n\n  /**\n   * Make request for the Git Pull API.\n   *\n   * @param auth Optional authentication information for the remote repository\n   * @returns Command execution status\n   */\n  pull(auth?: Git.IAuth): Promise<Git.IPushPullResult>;\n\n  /**\n   * Make request for the Git Push API.\n   *\n   * @param auth Optional authentication information for the remote repository\n   * @returns Command execution status\n   */\n  push(auth?: Git.IAuth): Promise<Git.IPushPullResult>;\n\n  /**\n   * General Git refresh\n   */\n  refresh(): Promise<void>;\n\n  /**\n   * Make request for a list of all Git branches\n   */\n  refreshBranch(): Promise<void>;\n\n  /**\n   * Request Git status refresh\n   */\n  refreshStatus(): Promise<void>;\n\n  /**\n   * Register a new diff provider for specified file types\n   *\n   * @param filetypes File type list\n   * @param callback Callback to use for the provided file types\n   */\n  registerDiffProvider(filetypes: string[], callback: Git.IDiffCallback): void;\n\n  /**\n   * Make request to move one or all files from the staged to the unstaged area\n   *\n   * If filename is not provided, all files will be reset.\n   *\n   * @param filename Optional name of the file to add\n   */\n  reset(filename?: string): Promise<Response>;\n\n  /**\n   * Make request to reset to selected commit\n   *\n   * @param commitId Selected commit ID\n   */\n  resetToCommit(commitId: string): Promise<Response>;\n\n  /**\n   * Make request for the prefix path of a directory 'path',\n   * with respect to the root directory of repository\n   *\n   * @param path Path for which the prefix is searched for\n   * @returns Path prefix\n   */\n  showPrefix(path: string): Promise<Git.IShowPrefixResult>;\n\n  /**\n   * Make request for top level path of repository 'path'\n   *\n   * @param path Path from which the top Git repository needs to be found\n   */\n  showTopLevel(path: string): Promise<Git.IShowTopLevelResult>;\n\n  /**\n   * Ensure a .gitignore file exists\n   */\n  ensureGitignore(): Promise<Response>;\n\n  /**\n   * Add an entry in .gitignore file\n   *\n   * @param filename The name of the entry to ignore\n   * @param useExtension Ignore all files having the same extension as filename\n   */\n  ignore(filename: string, useExtension: boolean): Promise<Response>;\n\n  /*\n   * Make request to list all the tags present in the remote repo\n   *\n   * @returns list of tags\n   */\n  tags(): Promise<Git.ITagResult>;\n\n  /**\n   * Make request to checkout the specified tag version\n   *\n   * @param tag of the version to checkout\n   */\n  checkoutTag(tag: string): Promise<Git.ICheckoutResult>;\n}\n\nexport namespace Git {\n  /** Function type for diffing a file's revisions */\n  export type IDiffCallback = (\n    filename: string,\n    revisionA: string,\n    revisionB: string\n  ) => void;\n\n  /**\n   * Interface for GitAllHistory request result,\n   * has all repo information\n   */\n  export interface IAllHistory {\n    code: number;\n    data?: {\n      show_top_level?: IShowTopLevelResult;\n      branch?: IBranchResult;\n      log?: ILogResult;\n      status?: IStatusResult;\n    };\n  }\n\n  /**\n   * Interface for server settings\n   */\n  export interface IServerSettings {\n    /**\n     * Frontend version formatted as Python package version\n     */\n    frontendVersion?: string;\n    /**\n     * Git version (X.Y.Z)\n     */\n    gitVersion?: string;\n    /**\n     * Server absolute root path (as posix)\n     */\n    serverRoot: string;\n    /**\n     * Server extension version formatted as Python package version\n     */\n    serverVersion: string;\n  }\n\n  /** Interface for GitShowTopLevel request result,\n   * has the Git root directory inside a repository\n   */\n  export interface IShowTopLevelResult {\n    code: number;\n    top_repo_path?: string;\n  }\n\n  /** Interface for GitShowPrefix request result,\n   * has the prefix path of a directory in a repository,\n   * with respect to the root directory.\n   */\n  export interface IShowPrefixResult {\n    code: number;\n    under_repo_path?: string;\n  }\n\n  /**\n   * Interface to call the checkout method\n   *\n   * If a branch name is provided, check it out (with or without creating it)\n   * If a filename is provided, check the file out\n   * If nothing is provided, check all files out\n   */\n  export interface ICheckoutOptions {\n    /**\n     * Branch name\n     */\n    branchname?: string;\n    /**\n     * Is it a new branch?\n     */\n    newBranch?: boolean;\n    /**\n     * The commit (branch name, tag, or commit id) to which a new branch HEAD will point.\n     */\n    startpoint?: string;\n    /**\n     * Filename\n     */\n    filename?: string;\n  }\n\n  /** Interface for GitCheckout request result.\n   * For reporting errors in checkout\n   */\n  export interface ICheckoutResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Branch description interface\n   */\n  export interface IBranch {\n    is_current_branch: boolean;\n    is_remote_branch: boolean;\n    name: string;\n    upstream: string;\n    top_commit: string;\n    tag: string;\n  }\n\n  /** Interface for GitBranch request result,\n   * has the result of fetching info on all branches\n   */\n  export interface IBranchResult {\n    code: number;\n    branches?: IBranch[];\n    current_branch?: IBranch;\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of each changed file\n   */\n  export interface IStatusFileResult {\n    x: string;\n    y: string;\n    to: string;\n    from: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n  }\n\n  /**\n   * Changed file attributes\n   */\n  export interface IStatusFile extends IStatusFileResult {\n    status: Status;\n  }\n\n  /** Interface for GitStatus request result,\n   * has the status of the entire repo\n   */\n  export interface IStatusResult {\n    code: number;\n    files?: IStatusFileResult[];\n  }\n\n  /** Interface for changed_files request result\n   * lists the names of files that have differences between two commits\n   * or beween two branches, or that were changed by a single commit\n   */\n  export interface IChangedFilesResult {\n    code: number;\n    files?: string[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of a single past commit\n   */\n  export interface ISingleCommitInfo {\n    commit: string;\n    author: string;\n    date: string;\n    commit_msg: string;\n    pre_commit: string;\n  }\n\n  /** Interface for GitCommit request result,\n   * has the info of a committed file\n   */\n  export interface ICommitModifiedFile {\n    modified_file_path: string;\n    modified_file_name: string;\n    insertion: string;\n    deletion: string;\n    is_binary: boolean | null;\n    // filetype as determined by app.docRegistry\n    type?: DocumentRegistry.IFileType;\n  }\n\n  /** Interface for GitDetailedLog request result,\n   * has the detailed info of a single past commit\n   */\n  export interface ISingleCommitFilePathInfo {\n    code: number;\n    modified_file_note?: string;\n    modified_files_count?: string;\n    number_of_insertions?: string;\n    number_of_deletions?: string;\n    modified_files?: ICommitModifiedFile[];\n  }\n\n  /** Interface for GitLog request result,\n   * has the info of all past commits\n   */\n  export interface ILogResult {\n    code: number;\n    commits?: ISingleCommitInfo[];\n  }\n\n  export interface IIdentity {\n    name: string;\n    email: string;\n  }\n\n  /**\n   * Interface for the Git Auth request.\n   */\n  export interface IAuth {\n    username: string;\n    password: string;\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IGitClone {\n    current_path: string;\n    clone_url: string;\n    auth?: IAuth;\n  }\n\n  /**\n   * Structure for the request to the Git Clone API.\n   */\n  export interface IPushPull {\n    current_path: string;\n    auth?: IAuth;\n    cancel_on_conflict?: boolean;\n  }\n\n  /**\n   * Structure for the result of the Git Clone API.\n   */\n  export interface ICloneResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Structure for the result of the Git Push & Pull API.\n   */\n  export interface IPushPullResult {\n    code: number;\n    message?: string;\n  }\n\n  /**\n   * Interface for a marker obj\n   */\n  export interface IBranchMarker {\n    add(fname: string, mark: boolean): void;\n\n    get(fname: string): boolean;\n\n    set(fname: string, mark: boolean): void;\n\n    toggle(fname: string): void;\n  }\n\n  export type Status =\n    | 'untracked'\n    | 'staged'\n    | 'unstaged'\n    | 'partially-staged'\n    | null;\n\n  export interface ITagResult {\n    code: number;\n    message?: string;\n    tags?: string[];\n  }\n}\n\n/**\n * Log message severity.\n */\nexport type Severity = 'error' | 'warning' | 'info' | 'success';\n\n/**\n * Interface describing a component log message.\n */\nexport interface ILogMessage {\n  /**\n   * Message severity.\n   */\n  severity: Severity;\n\n  /**\n   * Message text.\n   */\n  message: string;\n}\n"]}